/**
 * @fileoverview Firestore Security Rules for EnrollEase Platform
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for private data and allows public read access to certain collections where writes are restricted to authorized users.
 *
 * Data Structure:
 * - /userProfiles/{userId}: Stores individual user profiles. Accessible only to the user themselves.
 * - /institutes/{instituteId}: Stores institute profiles.
 * - /institutes/{instituteId}/members/{userId}: Stores members of each institute.
 * - /users/{userId}/notes/{noteId}: Stores private notes for each user. Accessible only to the user themselves.
 * - /courses/{courseId}: Stores course information, owned by an institute.
 * - /courses/{courseId}/enrollments/{enrollmentId}: Stores enrollment information for each course.
 * - /announcements/{announcementId}: Stores system-wide announcements. Writable only by admins.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Read-only access is granted to the 'announcements' collection.
 * - Institutes can manage their members.
 *
 * Denormalization for Authorization:
 * - The 'Course' entity requires an 'instituteId' to enforce ownership and manage access control.
 * - The 'Note' entity requires a 'userId' to enforce ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user profiles, ensuring only the user can access their own profile.
     * @path /userProfiles/{userId}
     * @allow (get, create, update, delete) if the user is the owner of the profile (userId matches request.auth.uid).
     * @deny (get, create, update, delete) if the userId does not match request.auth.uid.
     * @principle Enforces document ownership.
     */
    match /userProfiles/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false; // User listing is disallowed.
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) ;
      allow delete: if isOwner(userId) ;
    }

    /**
     * @description Secures institutes, allowing anyone to read institute information. Owner can create, update, and delete.
     * @path /institutes/{instituteId}
     * @allow (get, list) Anyone can read institute information.
     * @allow (create) if the user creating the institute sets the correct ownerId.
     * @allow (update, delete) if the user is the owner of the institute.
     * @deny (create, update, delete) if the user is not the owner.
     * @principle Allows public read access with owner-only writes.
     */
    match /institutes/{instituteId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(instituteId) {
          return isSignedIn() && get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId == request.auth.uid;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isOwner(instituteId) && resource != null;
      allow delete: if isOwner(instituteId) && resource != null;
    }

     /**
      * @description Secures institute members, mirroring user profiles within an institute's context.
      * @path /institutes/{instituteId}/members/{userId}
      * @allow (get, list) if the user is a member of the institute.
      * @allow (create, update, delete) if the user is an owner of the institute.
      * @deny (get, list) if the user is not a member of the institute.
      * @deny (create, update, delete) if the user is not the owner of the institute.
      * @principle Enforces institute-based access control for member profiles.
      */
    match /institutes/{instituteId}/members/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isInstituteOwner(instituteId) {
        return isSignedIn() && get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId == request.auth.uid;
      }

      allow get: if isInstituteOwner(instituteId);
      allow list: if isInstituteOwner(instituteId);
      allow create: if isInstituteOwner(instituteId);
      allow update: if isInstituteOwner(instituteId);
      allow delete: if isInstituteOwner(instituteId);
    }


    /**
     * @description Secures user notes, ensuring only the user can access their own notes.
     * @path /users/{userId}/notes/{noteId}
     * @allow (get, list, create, update, delete) if the user is the owner of the note (userId matches request.auth.uid).
     * @deny (get, list, create, update, delete) if the userId does not match request.auth.uid.
     * @principle Enforces document ownership for user-specific data.
     */
    match /users/{userId}/notes/{noteId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isOwner(userId) && resource != null && resource.data.userId == userId;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Secures courses, allowing anyone to read course information.  Only the institute that owns the course can create, update, and delete it.
     * @path /courses/{courseId}
     * @allow (get, list) Anyone can read course information.
     * @allow (create) if the user creating the course is the owner of the institute.
     * @allow (update, delete) if the user is the owner of the institute.
     * @deny (create, update, delete) if the user is not the owner of the institute.
     * @principle Allows public read access with owner-only writes.
     */
    match /courses/{courseId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isInstituteOwner(instituteId) {
            return isSignedIn() && get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId == request.auth.uid;
        }

        allow get, list: if true;
        allow create: if isSignedIn() && isInstituteOwner(request.resource.data.instituteId);
        allow update: if isSignedIn() && isInstituteOwner(resource.data.instituteId) && resource != null;
        allow delete: if isSignedIn() && isInstituteOwner(resource.data.instituteId) && resource != null;
    }

    /**
     * @description Secures course enrollments, allowing only the institute to manage enrollments.
     * @path /courses/{courseId}/enrollments/{enrollmentId}
     * @allow (get, list) if the user is enrolled in the course OR an admin of the institute
     * @allow (create, update, delete) if the user is the owner of the institute.
     * @deny (create, update, delete) if the user is not the owner of the institute.
     * @principle Enforces institute-based access control for enrollments.
     */
    match /courses/{courseId}/enrollments/{enrollmentId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isInstituteOwner(instituteId) {
          return isSignedIn() && get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId == request.auth.uid;
      }

      allow get, list: if isSignedIn() && isInstituteOwner(get(/databases/$(database)/documents/courses/$(courseId)).data.instituteId);
      allow create: if isSignedIn() && isInstituteOwner(get(/databases/$(database)/documents/courses/$(courseId)).data.instituteId);
      allow update: if isSignedIn() && isInstituteOwner(get(/databases/$(database)/documents/courses/$(courseId)).data.instituteId) && resource != null;
      allow delete: if isSignedIn() && isInstituteOwner(get(/databases/$(database)/documents/courses/$(courseId)).data.instituteId) && resource != null;
    }

    /**
     * @description Secures announcements, allowing anyone to read announcements, but only admins can create, update, and delete them.
     * @path /announcements/{announcementId}
     * @allow (get, list) Anyone can read announcements.
     * @allow (create, update, delete) if the user has the 'admin' role.
     * @deny (create, update, delete) if the user does not have the 'admin' role.
     * @principle Allows public read access with admin-only writes.
     */
    match /announcements/{announcementId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isAdmin() {
        return isSignedIn() && get(/databases/$(database)/documents/userProfiles/$(request.auth.uid)).data.role == 'admin';
      }

      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

       /**
        * @description Prevents listing of chatSessions.
        * @path /userProfiles/{userId}/chatSessions
        * @deny list: Listing is disallowed. This rule directly addresses the reported error by denying the 'list' operation on this path.
        * @principle Prevents unauthorized listing of private chat session data.
        */
       match /userProfiles/{userId}/chatSessions {
          allow get: if false; // You might want to define rules to allow `get` requests.
          allow list: if false;
          allow create: if false; // Define how/if chat sessions can be created.
          allow update: if false; // Define how/if chat sessions can be updated.
          allow delete: if false; // Define how/if chat sessions can be deleted.
      }
  }
}