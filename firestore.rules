/**
 * @fileoverview Firestore Security Rules for EnrollEase.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for personal data and a role-based model for institutes and courses.
 * It prioritizes security by default, restricting access unless explicitly granted.
 *
 * Data Structure:
 * - /userProfiles/{userId}: Stores individual user profiles, accessible only by the user.
 * - /institutes/{instituteId}: Stores institute profiles.
 * - /institutes/{instituteId}/members/{userId}: Stores members of an institute.
 * - /users/{userId}/notes/{noteId}: Stores notes specific to a user, accessible only by the user.
 * - /courses/{courseId}: Stores course information, owned by an institute.
 * - /courses/{courseId}/enrollments/{enrollmentId}: Tracks student enrollments in courses.
 * - /announcements/{announcementId}: Stores system-wide announcements, writable only by admins.
 *
 * Key Security Decisions:
 * - User profiles are private and only accessible to the authenticated user.
 * - Institutes have owners who can manage members and courses.
 * - Public listing of user profiles is disallowed for privacy.
 * - Announcements are globally readable but only writable by admins (not implemented in this prototype).
 *
 * Denormalization for Authorization:
 * - Institute documents should contain an `ownerId` field to easily authorize institute management operations.
 * - Course documents contain an `instituteId` field to authorize course management by institute owners.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Only the authenticated user can read and write their own profile.
     * @path /userProfiles/{userId}
     * @allow (get, update, delete) User with ID 'user123' can read/write their own profile.
     * @allow (create) User with ID 'user123' can create their own profile if request.auth.uid == 'user123'
     * @deny (get, update, delete) User with ID 'user456' cannot read/write profile of user with ID 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /userProfiles/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false; // Disable listing of all user profiles

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Secure institutes. Only the owner can create, update, and delete institutes.
     * @path /institutes/{instituteId}
     * @allow (create) Institute owner can create a new institute.
     * @allow (get, list) Anyone can read/list institutes.
     * @deny (update, delete) Non-owner cannot update/delete an institute.
     * @principle Enforces institute ownership for write operations.
     */
    match /institutes/{instituteId} {
      function isInstituteOwner() {
          return request.auth.uid == resource.data.ownerId;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && isInstituteOwner();
      allow delete: if isSignedIn() && isInstituteOwner();
    }

    /**
     * @description Secure institute members. Only the institute owner can manage members.
     * @path /institutes/{instituteId}/members/{userId}
     * @allow (get, list) Anyone can read/list institute members.
     * @allow (create) Institute owner can add a new member.
     * @deny (update, delete) Non-owner cannot update/delete institute members.
     * @principle Enforces institute ownership for member management.
     */
    match /institutes/{instituteId}/members/{userId} {
      function isInstituteOwner(instituteId) {
        return get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId == request.auth.uid;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if true; //TODO:  review if we need to restrict listing members to just the institute owners.

      // WARNING: Creating a subresource using a client-specified ID can lead to serious security problems.
      // A malicious client can overwrite an exising document because they know the exact document path.
      // You should strongly consider auto-generating all subcollection IDs on the backend, or
      // implement strong validation that the new ID is, in fact, new and unique.
      allow create: if isSignedIn() && isInstituteOwner(instituteId);

      allow update: if isSignedIn() && isInstituteOwner(instituteId);
      allow delete: if isSignedIn() && isInstituteOwner(instituteId);
    }

    /**
     * @description Secure user notes. Only the authenticated user can read and write their own notes.
     * @path /users/{userId}/notes/{noteId}
     * @allow (get, list, create, update, delete) User with ID 'user123' can manage their own notes.
     * @deny (get, list, create, update, delete) User with ID 'user456' cannot manage notes of user with ID 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/notes/{noteId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Secure courses. Only the institute that owns the course can create, update, and delete it.
     * @path /courses/{courseId}
     * @allow (get, list) Anyone can read/list courses.
     * @allow (create) Institute owner can create a new course.
     * @deny (update, delete) Non-owner cannot update/delete a course.
     */
    match /courses/{courseId} {
      function isInstituteOwner(instituteId) {
          return get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId == request.auth.uid;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && isInstituteOwner(request.resource.data.instituteId);
      allow update: if isSignedIn() && isInstituteOwner(resource.data.instituteId);
      allow delete: if isSignedIn() && isInstituteOwner(resource.data.instituteId);
    }

    /**
     * @description Secure course enrollments. Only the institute that owns the course can manage enrollments.
     * @path /courses/{courseId}/enrollments/{enrollmentId}
     * @allow (get, list) Anyone can read/list enrollments.
     * @allow (create, update, delete) Institute owner can manage enrollments.
     * @deny (create, update, delete) Non-owner cannot manage enrollments.
     */
    match /courses/{courseId}/enrollments/{enrollmentId} {
      function isCourseOwnedByInstitute(courseId) {
        return get(/databases/$(database)/documents/courses/$(courseId)).data.instituteId;
      }

      function isInstituteOwner(instituteId) {
          return get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId == request.auth.uid;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if true;

      // WARNING: Creating a subresource using a client-specified ID can lead to serious security problems.
      // A malicious client can overwrite an exising document because they know the exact document path.
      // You should strongly consider auto-generating all subcollection IDs on the backend, or
      // implement strong validation that the new ID is, in fact, new and unique.
      allow create: if isSignedIn() && isInstituteOwner(isCourseOwnedByInstitute(courseId));
      allow update: if isSignedIn() && isInstituteOwner(isCourseOwnedByInstitute(courseId));
      allow delete: if isSignedIn() && isInstituteOwner(isCourseOwnedByInstitute(courseId));
    }

    /**
     * @description Secure announcements. Only admins can create announcements. Everyone can read them.
     * @path /announcements/{announcementId}
     * @allow (get, list) Anyone can read/list announcements.
     * @deny (create, update, delete) Non-admin cannot create/update/delete announcements.
     */
    match /announcements/{announcementId} {
        // TODO: Implement admin role check
        function isAdmin() {
            return false; // Placeholder: Implement admin check logic here
        }
        function isSignedIn() {
          return request.auth != null;
        }

        allow get, list: if true;
        allow create: if isSignedIn() && isAdmin();
        allow update: if isSignedIn() && isAdmin();
        allow delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Secure chat sessions within a user profile. Only the authenticated user can list their own chat sessions.
     * @path /userProfiles/{userId}/chatSessions/{chatSessionId}
     * @allow (list) User with ID 'user123' can list their own chat sessions.
     * @deny (list) User with ID 'user456' cannot list chat sessions of user with ID 'user123'.
     * @principle Enforces document ownership for listing operations.
     */
    match /userProfiles/{userId}/chatSessions/{chatSessionId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}