/**
 * @fileoverview Firestore Security Rules for EnrollEase.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data
 * while allowing public read access to some collections and admin-only write access to others.
 * Data validation is relaxed to allow for rapid prototyping and iteration.
 *
 * Data Structure:
 * - /userProfiles/{userId}: Stores user profile information, accessible only to the user themselves.
 * - /institutes/{instituteId}: Stores institute information.
 * - /institutes/{instituteId}/members/{userId}: Stores members of the institute.
 * - /users/{userId}/notes/{noteId}: Stores user-specific notes, accessible only to the user.
 * - /courses/{courseId}: Stores course information, owned by an institute.
 * - /courses/{courseId}/enrollments/{enrollmentId}: Tracks enrollments for a course.
 * - /announcements/{announcementId}: Stores system-wide announcements, writeable only by admins.
 * - /userProfiles/{userId}/chatSessions/{sessionId}/messages/{messageId}: Stores chat messages for a specific session owned by the user.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Write operations are generally restricted to the owner of the document or an admin.
 * - Data validation is minimal in this prototyping phase.
 *
 * Denormalization for Authorization:
 * - The `instituteId` field on the `Course` entity is used to determine which institute owns the course. This denormalization avoids the need for complex queries in the security rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profiles. Users can only read/write their own profile.
     * @path /userProfiles/{userId}
     * @allow (read, write) if request.auth.uid == userId
     * @deny (read, write) if request.auth.uid != userId
     * @principle Enforces document ownership for all operations.
     */
    match /userProfiles/{userId} {
      // Only allow read access to the user's own profile.
      allow get: if isOwner(userId);
      allow list: if false; // Disable listing user profiles for privacy.

      // Only allow creating a profile if the user ID matches the authenticated user.
      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;

      // Only allow updating a profile if the user ID matches the authenticated user.
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;

      // Only allow deleting a profile if the user ID matches the authenticated user.
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Protects institutes. Anyone can read institutes, but only the owner can create, update, or delete.
     * @path /institutes/{instituteId}
     * @allow (read) if true
     * @allow (create) if request.auth.uid == request.resource.data.ownerId
     * @allow (update, delete) if resource.data.ownerId == request.auth.uid
     * @deny (create, update, delete) if request.auth.uid != request.resource.data.ownerId
     * @principle Enforces document ownership for writes, allows public reads.
     */
    match /institutes/{instituteId} {
      // Anyone can read institutes.
      allow get, list: if true;

      // Only the owner can create an institute.
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;

      // Only the owner can update an existing institute.
      allow update: if isExistingOwner(resource.data.ownerId);

      // Only the owner can delete an existing institute.
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Manages institute members. Access is based on institute ownership.
     * @path /institutes/{instituteId}/members/{userId}
     * @allow (read) if true
     * @allow (create) if get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId == request.auth.uid
     * @allow (update, delete) if get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId == request.auth.uid
     * @principle Enforces ownership via parent document lookup.
     */
    match /institutes/{instituteId}/members/{userId} {
        // Allow read for any member
        allow get, list: if true;

        // Only institute owner can create new members
        allow create: if isSignedIn() && get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId == request.auth.uid;

        // Only institute owner can update members
        allow update: if isSignedIn() && get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId == request.auth.uid;

        // Only institute owner can delete members
        allow delete: if isSignedIn() && get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId == request.auth.uid;
    }

    /**
     * @description Protects user notes. Users can only read/write their own notes.
     * @path /users/{userId}/notes/{noteId}
     * @allow (read, write) if request.auth.uid == userId
     * @deny (read, write) if request.auth.uid != userId
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/notes/{noteId} {
      // Only allow read access to the user's own notes.
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      // Only allow creating a note if the user ID matches the authenticated user.
      allow create: if isOwner(userId) && request.resource.data.userId == userId;

      // Only allow updating a note if the user ID matches the authenticated user.
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;

      // Only allow deleting a note if the user ID matches the authenticated user.
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Protects courses. Anyone can read courses, but only the institute that owns the course can create, update, or delete.
     * @path /courses/{courseId}
     * @allow (read) if true
     * @allow (create) if get(/databases/$(database)/documents/institutes/$(request.resource.data.instituteId)).data.ownerId == request.auth.uid
     * @allow (update, delete) if get(/databases/$(database)/documents/institutes/$(resource.data.instituteId)).data.ownerId == request.auth.uid
     * @principle Enforces institute ownership for writes, allows public reads.
     */
    match /courses/{courseId} {
      // Anyone can read courses.
      allow get, list: if true;

      // Only the institute can create a course.  We look up the institute by the instituteId in the data.
      allow create: if isSignedIn() && get(/databases/$(database)/documents/institutes/$(request.resource.data.instituteId)).data.ownerId == request.auth.uid;

      // Only the institute can update an existing course.
      allow update: if isSignedIn() && resource != null && get(/databases/$(database)/documents/institutes/$(resource.data.instituteId)).data.ownerId == request.auth.uid;

      // Only the institute can delete an existing course.
      allow delete: if isSignedIn() && resource != null && get(/databases/$(database)/documents/institutes/$(resource.data.instituteId)).data.ownerId == request.auth.uid;
    }

    /**
     * @description Manages course enrollments. Access is based on course ownership by an institute.
     * @path /courses/{courseId}/enrollments/{enrollmentId}
     * @allow (read) if true
     * @allow (create) if get(/databases/$(database)/documents/courses/$(courseId)).data.instituteId in get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId
     * @allow (update, delete) if get(/databases/$(database)/documents/courses/$(courseId)).data.instituteId in get(/databases/$(database)/documents/institutes/$(instituteId)).data.ownerId
     * @principle Enforces ownership via parent document lookup.
     */
    match /courses/{courseId}/enrollments/{enrollmentId} {
        // Allow read for anyone
        allow get, list: if true;

        // Only institute owner can create new enrollments
        allow create: if isSignedIn() && get(/databases/$(database)/documents/courses/$(courseId)).data.instituteId in get(/databases/$(database)/documents/institutes/{instituteId}).data.ownerId;

        // Only institute owner can update enrollments
        allow update: if isSignedIn() && get(/databases/$(database)/documents/courses/$(courseId)).data.instituteId in get(/databases/$(database)/documents/institutes/{instituteId}).data.ownerId;

        // Only institute owner can delete enrollments
        allow delete: if isSignedIn() && get(/databases/$(database)/documents/courses/$(courseId)).data.instituteId in get(/databases/$(database)/documents/institutes/{instituteId}).data.ownerId;
    }

    /**
     * @description Protects announcements. Anyone can read announcements, but only admins can create, update, or delete.
     * @path /announcements/{announcementId}
     * @allow (read) if true
     * @allow (create, update, delete) if false // TODO: Add admin check (e.g., isAdmin())
     * @principle Restricts writes to admins, allows public reads.
     */
    match /announcements/{announcementId} {
      // Anyone can read announcements.
      allow get, list: if true;

      // Only admins can create, update, or delete announcements.
      allow create, update, delete: if false; // TODO: Add admin check (e.g., isAdmin())
    }
    
    /**
     * @description Protects chat messages. Users can only read/write their own chat messages.
     * @path /userProfiles/{userId}/chatSessions/{sessionId}/messages/{messageId}
     */
    match /userProfiles/{userId}/chatSessions/{sessionId}/messages/{messageId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}